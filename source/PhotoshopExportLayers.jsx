/*@author igor almeida*/var foo ={	selected_list: [],	doc: null,	mode: -1,	mode_all_visible: 0,	mode_selected: 1,	save_as : null,	save_png : 0,	save_jpg : 1,	export_quality : 100,	export_format : SaveDocumentType.PNG,/*	getting the current document.	and looking for selected layers.*/	init: function()	{		this.doc = app.activeDocument;		if (!this.doc)		{			alert("No document found!");			return;		}		try		{			this.doc.path;		}		catch(err)		{			alert("This document isn't saved");			return;		}		this.mode = parseFloat(prompt("What would you like to export?\n(0) All visible layers | (1) Only selected", 0));		this.selected_list = [];		switch (this.mode)		{			case this.mode_all_visible:				this.inspectLayers(this.doc.layers);				break;			case this.mode_selected:				// just selected. it works for groups and single layer.				if (this.doc.activeLayer.typename == "ArtLayer")				{					this.addLayerToList(this.doc.activeLayer);				}				else				{					this.inspectLayers(this.doc.activeLayer.layers);				}				break;			default:				alert("You should have chosen 0 or 1.");				break;		}		if (this.selected_list.length > 0)		{			this.save_as = parseFloat(prompt("In which format would you like to export?\n(0) PNG24 | (1) JPG", 0));			switch(this.save_as)			{				case this.save_jpg:					this.export_quality = parseFloat(prompt("Which quality?\n0 = low and 100 = full quality", 60));					this.export_quality = Math.max( 0, this.export_quality );					this.export_quality = Math.min( 100, this.export_quality );					this.export_format = SaveDocumentType.JPEG;					break;				case this.save_png:					this.export_quality = 100;					this.export_format = SaveDocumentType.PNG;					break;				default:					alert("You should have chosen 0 or 1.");					return;					break;			}			this.exportList();		}		else		{			alert("Nothing to export!");		}	},/*	inpect layers looking for selected layers to export	@param scope Layers object.*/	inspectLayers : function(scope)	{		var count = scope.length;		while (count--)		{			var layer = scope[count];			if (!layer)			{				// avoiding empty set.				return;			}			if (layer.typename == "ArtLayer")			{				this.addLayerToList(layer);			}			else if (layer.typename == "LayerSet")			{				// inspecting LayerSets				this.inspectLayers(layer.layers);			}		}	},/*	add a new layer to the export list.	@param layer*/	addLayerToList: function(layer)	{		//checking if the layer is visible and has content (empty layers wont be exported)		if (layer != null)		{			var v = layer.visible;			this.doc.activeLayer = layer;			layer.visible = v;			if ( layer.visible				&& !layer.grouped				&& !this.hasLayerMask()				&& !this.hasVectorMask()				&& !this.hasFilterMask()				&& !this.isOutOfBounds(layer) )			{				this.selected_list.push(layer);			}			// else			// {			// 	alert(layer.name+ " ignored!\n" + "invisible:"+!layer.visible+ "\ngrouped:"+layer.grouped+"\nlayer mask:"+this.hasLayerMask() +"\nvector mask:"+this.hasVectorMask()+"\nfilter mask:"+this.hasFilterMask()+ "\nout of bounds:"+ this.isOutOfBounds(layer) );			// }		}	},/*	export selected_list*/	exportList : function()	{		var layer;		var count = 0;		while (count<this.selected_list.length)		{			try			{				// getting a layer from the list and copying its content.				layer = this.selected_list[count];				layer.copy();			}			catch(err)			{				if (this.mode == this.mode_all_visible)				{					alert("Error exporting layer: " + layer.name + "\n" + err + "\n");				}				else if (this.mode == this.mode_selected)				{					alert("You can't select more than 1 layer. But if you want so, please put it in a group and then select the group. Stack error:"+err);				}				return;			}			// bounds model [x,y,width,height]			var w = Math.round(parseFloat(layer.bounds[2] - layer.bounds[0]));			var h = Math.round(parseFloat(layer.bounds[3] - layer.bounds[1]));						// figuring out where is the x and y considering that photoshop's register point is by default centered.			var x = Math.round(parseFloat(layer.bounds[0]));			var y = Math.round(parseFloat(layer.bounds[1]));						if (x<0)			{				w+=x; x = 0;			}			else if (x+w>this.doc.width.value)			{				w-=(x+w)-this.doc.width.value;			}			if (y<0)			{				h+=y; y = 0;			}			else if (y+h>this.doc.height.value)			{				h-=(y+h)-this.doc.height.value;			}			try			{				var mode = NewDocumentMode[app.activeDocument.mode.toString().split(".")[1]];				var bg = this.export_format == SaveDocumentType.PNG ? DocumentFill.TRANSPARENT : DocumentFill.WHITE;				// create a new file following the current doc options.				var layer_file = app.documents.add(w, h, this.doc.resoluition, layer.name, mode, bg, this.doc.pixelAspectRatio);				layer_file.paste();			}			catch(err)			{				alert("Error exporting layer:"+layer.name+". Stack:"+err);			}			// exporting png and closing file.			try			{				var ext = this.export_format == SaveDocumentType.PNG ? "png" : "jpg";				var file_name = layer.name.replace(/\W/g,"");				// all layers will be placed into a new directory called "<psd_name>-layers/"				var folder = new Folder(this.doc.path + "/" + this.doc.name + "-layers");				if (!folder.exists) folder.create();				// creating file.				var file = new File(folder.path + "/" + folder.name + "/" + (count<10?"0"+count:count) + "-" + file_name + "_" + x + "x" + y + "."+ext);				if (file.created) file.remove();				// export settings.				var exportOptions = new ExportOptionsSaveForWeb();					exportOptions.quality = this.export_quality;					exportOptions.PNG8 = false;					exportOptions.format = this.export_format;				layer_file.exportDocument(file, ExportType.SAVEFORWEB, exportOptions);				layer_file.close(SaveOptions.DONOTSAVECHANGES);				}			catch(err)			{				alert("Error exporting layer:"+layer.name+". Stack error:\n"+err);			}			count++;		}	},	// extracted from http://strangefamilymusic.net/hymnuts/BVBC/Artwork/CS4/App/Photoshop/Presets/Scripts/Flatten%20All%20Masks.jsx	hasLayerMask : function ()	{		var hasLayerMask = false;		try		{			var ref = new ActionReference();			var keyUserMaskEnabled = app.charIDToTypeID( 'UsrM' );			ref.putProperty( app.charIDToTypeID( 'Prpr' ), keyUserMaskEnabled );			ref.putEnumerated( app.charIDToTypeID( 'Lyr ' ), app.charIDToTypeID( 'Ordn' ), app.charIDToTypeID( 'Trgt' ) );			var desc = executeActionGet( ref );			if ( desc.hasKey( keyUserMaskEnabled ) )			{				hasLayerMask = true;			}		}		catch(e)		{			hasLayerMask = false;		}		return hasLayerMask;	},		// extracted from http://strangefamilymusic.net/hymnuts/BVBC/Artwork/CS4/App/Photoshop/Presets/Scripts/Flatten%20All%20Masks.jsx	hasVectorMask : function ()	{		var hasVectorMask = false;		try		{			var ref = new ActionReference();			var keyVectorMaskEnabled = app.stringIDToTypeID( 'vectorMask' );			var keyKind = app.charIDToTypeID( 'Knd ' );			ref.putEnumerated( app.charIDToTypeID( 'Path' ), app.charIDToTypeID( 'Ordn' ), keyVectorMaskEnabled );			var desc = executeActionGet( ref );			if ( desc.hasKey( keyKind ) )			{				var kindValue = desc.getEnumerationValue( keyKind );				if (kindValue == keyVectorMaskEnabled)				{					hasVectorMask = true;				}			}		}		catch(e)		{			hasVectorMask = false;		}		return hasVectorMask;	},	// extracted from http://strangefamilymusic.net/hymnuts/BVBC/Artwork/CS4/App/Photoshop/Presets/Scripts/Flatten%20All%20Masks.jsx	hasFilterMask : function ( )	{		var hasFilterMask = false;		try		{			var ref = new ActionReference();			var keyFilterMask = app.stringIDToTypeID("hasFilterMask");			ref.putProperty( app.charIDToTypeID( 'Prpr' ), keyFilterMask);			ref.putEnumerated( app.charIDToTypeID( 'Lyr ' ), app.charIDToTypeID( 'Ordn' ), app.charIDToTypeID( 'Trgt' ) );			var desc = executeActionGet( ref );			if ( desc.hasKey( keyFilterMask ) && desc.getBoolean( keyFilterMask ))			{				hasFilterMask = true;			}		}		catch(e)		{			hasFilterMask = false;		}		return hasFilterMask;	},/*	check if the layer's content is fully out of stage.	@param layer	@return Boolean*/	isOutOfBounds : function(layer)	{		if (!layer)		{			return true;		}		var a =		{			top:0,			left:0,			width:this.doc.width.value,			height:this.doc.height.value		};		var b =		{			top: Math.round(parseFloat(layer.bounds[1])),			left: Math.round(parseFloat(layer.bounds[0])),			width: Math.round(parseFloat(layer.bounds[2] - layer.bounds[0])),			height: Math.round(parseFloat(layer.bounds[3] - layer.bounds[1]))		};		return !(a.left <= b.left + b.width && b.left <= a.left + a.width && a.top <= b.top + b.height && b.top <= a.top + a.height);	}};foo.init();